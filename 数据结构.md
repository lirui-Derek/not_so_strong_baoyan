# 1、数据结构三要素

1. 逻辑结构

   - 集合
   - 线性结构——数组、栈和队列
   - 非线性结构——树、图

2. 存储结构——物理结构

   

   - **顺序存储**

   - **链式存储**

     头指针和头结点的区别

     头指针指向第一个结点存储位置的结点，具有标识作用，是链表的必要元素。

     头结点放在第一个元素结点之前，便于插入和删除操作

     - 单链表——头插法，尾插法，插入结点，删除结点，求表长
     - 双链表——插入、删除
     - 循环链表

     顺序表和链表的比较

     1、存取（读写）方式

     ​	顺序表可以顺序存取，也可以随机存取；

     ​	链表只能从表头顺序存取元素。

     2、逻辑结构与物理结构

     ​	顺序表相邻元素逻辑和物理上的地址都相邻。

     ​	链表物理上不一定相邻。

     3、查找、插入和删除操作

     ​	顺序O（n），折半查找O（$log_2^n$）

     ​	链表的平均时间复杂度为O（n）。

     4、空间分配

     ​	链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。

   - **索引存储**

     B+树

   - **散列存储——哈希存储**

   哈希（hash）是根据关键码值（Key value）而直接访问的数据结构。

   ​						通过把关键码值映射到表中一个位置来访问记录，来加快查找速度。

   ​						映射函数叫做散列函数，存放记录的数组叫做散列表。

   ​			哈希冲突：通过哈希函数计算出的哈希值相同。

   ​					解决哈希冲突的四个方法：

   ​					1、开放地址法——线性探测—— +1

   ​													二次探测—— +1，+4，+9    二次探测的步数是原始位置相隔的步数的平方。

   ​													再散列法，当关键字key的哈希地址p=H(key)出现冲突时，将p作为关键字，再产生一个哈希地址......直至不冲突。

   ​					2、拉链法——将所有关键字为同义字的记录存储在一个单链表中。

   ​					3、再哈希法——发生冲突的时候再用另外一个哈希函数算出哈希值，直到算出的哈希值不同为止。

   ​					4、建立公共溢出区——在创建哈希表的同时，再额外创建一个公共溢出区，专门用来存放哈希冲突的元素。查找时，先从哈希表查，查不到再去公共溢出区。

3. 数据的运算



# 2、排序

![image-20220724190803058](C:\Users\lirui\AppData\Roaming\Typora\typora-user-images\image-20220724190803058.png)

### 1、快速排序quicksort

1. 从数列中挑出一个元素，称为"基准"（pivot）
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
   递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
3. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。



Pick a pivot from the sequence. Reorder the sequence, all elements smaller than the pivot are placed in front of it, and all elements larger than the pivot are placed behind. The pivot is in the middle. This is called partition. Recursively sort subarrays of elements smaller than pivot and subarrays of elements larger than the pivot.

基本点：1、基准



 

### 2、基数排序

基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。
具体做法是：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

### 3、希尔排序



# 3、最小生成树

方法：

Prim算法

克鲁斯卡尔算法——判断是否成环：并查集



# 4、栈

## 1、用栈实现计算器

核心是将中缀表达式转化为后缀表达式

初始化两个栈，分别是符号栈s1和中间结果栈s2。

从左往右扫描中缀表达式，遇到操作数压入s2，

遇到括号：左括号压入s1，右括号，依次弹出运算符并压入s2，直到遇到左括号，丢弃这对括号。

遇到运算符：与s1栈顶运算符比较优先级：

如果栈为空，或者栈顶元素为左括号，直接入栈

如果优先级大于栈顶优先级，也直接入栈，如果优先级小于栈顶优先级，则一直弹出栈顶，并压入。

一直到最右边，将s1中剩余压入s2

一次弹出s2中所有元素并输出，结果的逆序即为对应的后缀表达式

## 2、栈在括号匹配中的应用

![image-20220729093841141](C:\Users\lirui\AppData\Roaming\Typora\typora-user-images\image-20220729093841141.png)

## 3、堆和栈的区别

堆和栈的区别主要有五大点，分别是：

1、申请方式的不同。栈由系统自动分配，而堆是人为申请开辟;

2、申请大小的不同。栈获得的空间较小，而堆获得的空间较大;

3、申请效率的不同。栈由系统自动分配，速度较快，而堆一般速度比较慢;

4、存储内容的不同。栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不入栈的。而堆一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排;

5、底层不同。栈是连续的空间——运算受阻的线性表——先入后出，而堆是不连续的空间——完全二叉树。



# 5、KMP算法

面试官问：你知道什么是KMP算法吗？说说你对KMP算法的理解。

答：**KMP算法是用来进行字符串匹配查找的，比如在字符串1中查找是否包含字符串2。核心是先求出Next数组。**

​		**什么是next数组？我的理解是：next数组表示的是待查找的字符串的  最大公共前后缀  中的公共前缀的最后一个字符的下标，知道这个下标，就可以知道当匹配目标字符串出错时，目标字符串的指针怎么回退，而查找段落的指针不用回退，这样遍历一遍查找段落，就可以知道是否存在目标字符串，时间复杂度为O（n）。**



# 6、红黑树

## 1、五个特性

- 节点非黑即红

- 根节点为黑色

- 

# 7、哈夫曼树

​		从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该结点的带权路径长度。

​		树中所有叶结点的带权路径长度之和称为该树的带权路径长度。

## 构造哈夫曼树

​		每次取两个结点权值最小的结点作为左右子树，并且将新结点的权值置为左右子树上根结点的权值之和。

​		删除刚才选出的两个结点值，同时将新得到的结点值

## 哈夫曼树的特点

1、权值越小的结点到根结点的路径长度越大。

2、构造过程中共新建了n-1个结点，因此哈夫曼树的结点总数为2n-1。

3、哈夫曼树中不存在度为1的结点。



# 8、完全二叉树与满二叉树

## 完全二叉树：

​		一棵深度为k的n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

满二叉树一定是完全二叉树，完全二叉树未必是满二叉树。

## 满二叉树：		

​		一棵深度为k且有$2^k-1$个结点的二叉树称为满二叉树。

​		每一层的结点数都是最大结点数。

​		叶子节点全部都在最底层。

## 不同点：

# 8、拓扑排序

# 9、程序编译过程

![img](https://img-blog.csdnimg.cn/af9196bbb6c74c29875b9770aa183679.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiO5L2g55qE6Led56a75peg56m35bCP,size_12,color_FFFFFF,t_70,g_se,x_16)

预处理：预编译的执行过程，主要处理源代码中的预处理指令。

编译：编译过程实际上就是对 **.i** 后缀的文件进行**语法、词法、语义分析，符号汇总，最后生成汇编代码**。

汇编：将汇编代码转换成二进制文件，二进制文件使可以让机器直接读取的文件。

链接：链接程序的主要工作就是将有关系的目标文件连接起来，使得所有的这些目标文件都能够被操作系统装入执行。

![image-20220804172253072](C:\Users\lirui\AppData\Roaming\Typora\typora-user-images\image-20220804172253072.png)

# 10、C语言中文本文件与二进制文件的区别？

## 定义上：

文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码等等（基本上是定长编码的）。

二进制文件是基于值编码的文件（变长编码的）。

## 存取上：

C的文本读写与二进制的读写的差别体现在换行符的处理上。

文本方式读写时，每遇到一个“\n”，就将其换成“\r\n”，然后再写入文件；当文本读取时，它每遇到一个“\r\n”，将其转换为“\n”，然后送到读缓冲区。

二进制读写时，不需要任何转换，直接将写缓冲区的数据写入文件。
